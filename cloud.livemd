# Image Prediction using a Standalone Wasm Binary on GCP

```elixir
Mix.install(
  [
    {:nx, "~> 0.5.1"},
    {:nx_image, "~> 0.1.0"},
    {:kino, "~> 0.8.1"},
    {:req, "~> 0.3.5"},
    {:benchee, "~> 1.1.0"},
    {:wasmtube, github: "kentaro/wasmtube", branch: :main}
  ]
)
```

## Experimental environment

* Machine: Google Cloud Compute Engine e2-medium (*)
  * CPU: 2 vCPU (Intel Broadwell)
  * Architecture: x86/64
  * Memory: 4GB
* OS: Debian GNU/Linux 11
* Runtime: Elixir v1.14.3

This is a cost-optimized type of VM widely used for GCP users.

ref. [Machine families resource and comparison guide  |  Compute Engine Documentation | Google Cloud](https://cloud.google.com/compute/docs/machine-resource#recommendations_for_machine_types)

## Uploading an image to be predicted

```elixir
input = Kino.Input.image("Upload an image to be predicted")
```

This is a sample image that is used in this livebook.

![](https://upload.wikimedia.org/wikipedia/commons/4/40/Just_one_lion.jpg?20061206183417)
[File:Just one lion.jpg - Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Just_one_lion.jpg)

## Preprocessing the image

```elixir
image = input |> Kino.Input.read()

nx_image =
  image.data
  |> Nx.from_binary(:u8)
  |> Nx.reshape({image.height, image.width, 3})
  |> NxImage.resize({224, 224}, method: :nearest)

kino_image =
  nx_image
  |> Kino.Image.new()
```

## Preparing label data

```elixir
label_data =
  Req.get!("https://raw.githubusercontent.com/kazum/tvm-wasm/master/synset.csv")
  |> Map.get(:body)
  |> String.trim()
  |> String.split("\r\n")
  |> Enum.reduce(%{}, fn line, acc ->
    [k, v] = line |> String.split(",", parts: 2)
    acc |> Map.put(String.to_integer(k), v)
  end)
```

## Prediction with Wasm binary

```elixir
resnet50_wasm =
  Wasmtube.from_file("/home/antipop/elixir-ml-wasm/wasm/resnet50.wasm")

result =
  resnet50_wasm
  |> Wasmtube.call_function("predict", image: kino_image.content, width: 224, height: 224)
```

## Find an index whose value is highest

```elixir
{max_index, max_value} =
  result
  |> Map.get("data")
  |> Enum.with_index()
  |> Enum.reduce({0, 0}, fn {v, i}, acc ->
    {_, max_value} = acc

    if v > max_value do
      {i, v}
    else
      acc
    end
  end)

{max_index, max_value}
```

## Prediction result

```elixir
label_data[max_index]
```

## Benchmark

```elixir
resnet50_wasm_func = fn ->
  resnet50_wasm
  |> Wasmtube.call_function("predict", image: kino_image.content, width: 224, height: 224)
end

Benchee.run(%{
  "Wasm (ResNet50)" => resnet50_wasm_func
})
```
